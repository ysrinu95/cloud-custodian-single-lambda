name: Test Cloud Custodian Policies

on:
  workflow_dispatch:
    inputs:
      policy_file:
        description: 'Policy file to test (e.g., sample-policies.yml, test-policy.yml)'
        required: true
        type: string
        default: 'test-policy.yml'
      test_action:
        description: 'Test action to perform'
        required: true
        type: choice
        options:
          - validate-only
          - dry-run
          - live-test
        default: 'validate-only'
      environment:
        description: 'Environment for live testing'
        required: false
        type: choice
        options:
          - dev
          - staging
        default: 'dev'

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: "3.11"
  MEMBER_ACCOUNT_ID: "813185901390"
  CENTRAL_ACCOUNT_ID: "172327596604"

permissions:
  id-token: write
  contents: read

jobs:
  # ======================================================================
  # Job 1: Validate Policy Syntax
  # ======================================================================
  validate-policy:
    name: Validate Policy - ${{ inputs.policy_file }}
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Cloud Custodian
        run: |
          pip install c7n c7n-org pyyaml boto3
          echo "Cloud Custodian version:"
          custodian version
      
      - name: Validate YAML syntax
        run: |
          echo "üîç Validating YAML syntax..."
          
          POLICY_PATH="policies/${{ inputs.policy_file }}"
          
          if [ ! -f "$POLICY_PATH" ]; then
            echo "::error::Policy file not found: $POLICY_PATH"
            exit 1
          fi
          
          # Validate YAML syntax
          python -c "import yaml; yaml.safe_load(open('$POLICY_PATH'))"
          echo "‚úÖ YAML syntax is valid"
      
      - name: Validate Cloud Custodian policy
        run: |
          echo "üîç Validating Cloud Custodian policy..."
          
          POLICY_PATH="policies/${{ inputs.policy_file }}"
          
          # Validate policy structure
          custodian validate "$POLICY_PATH"
          echo "‚úÖ Policy validation successful!"
      
      - name: Analyze policy
        run: |
          echo "üìä Analyzing policy structure..."
          
          POLICY_PATH="policies/${{ inputs.policy_file }}"
          
          # Extract policy names
          echo "Policies in file:"
          python <<EOF
          import yaml
          with open('$POLICY_PATH') as f:
              data = yaml.safe_load(f)
              for policy in data.get('policies', []):
                  print(f"  - {policy['name']}: {policy['resource']}")
                  print(f"    Filters: {len(policy.get('filters', []))}")
                  print(f"    Actions: {len(policy.get('actions', []))}")
          EOF
      
      - name: Generate validation report
        run: |
          cat <<EOF > validation-report.md
          ## ‚úÖ Policy Validation Report
          
          **Policy File:** \`${{ inputs.policy_file }}\`
          **Test Action:** \`${{ inputs.test_action }}\`
          **Validation Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Triggered by:** ${{ github.actor }}
          
          ### Validation Results
          
          - ‚úÖ YAML syntax: PASSED
          - ‚úÖ Cloud Custodian schema: PASSED
          - ‚úÖ Policy structure: VALID
          
          ### Policy Details
          
          $(python -c "
          import yaml
          with open('policies/${{ inputs.policy_file }}') as f:
              data = yaml.safe_load(f)
              for policy in data.get('policies', []):
                  print(f\"- **{policy['name']}**\")
                  print(f\"  - Resource: {policy['resource']}\")
                  print(f\"  - Filters: {len(policy.get('filters', []))}\")
                  print(f\"  - Actions: {len(policy.get('actions', []))}\")
          ")
          
          EOF
          
          cat validation-report.md
      
      - name: Upload validation report
        uses: actions/upload-artifact@v4
        with:
          name: validation-report-${{ inputs.policy_file }}
          path: validation-report.md
          retention-days: 30

  # ======================================================================
  # Job 2: Create Test EC2 Instance
  # ======================================================================
  create-test-ec2:
    name: Create Test EC2 Instance
    runs-on: ubuntu-latest
    needs: validate-policy
    if: inputs.test_action == 'live-test'
    
    outputs:
      instance_id: ${{ steps.create.outputs.instance_id }}
      volume_id: ${{ steps.attach.outputs.volume_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials (Central Account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.CENTRAL_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Assume role in Member Account
        run: |
          echo "üîê Assuming OrganizationAccountAccessRole in member account..."
          
          CREDENTIALS=$(aws sts assume-role \
            --role-arn "arn:aws:iam::${{ env.MEMBER_ACCOUNT_ID }}:role/OrganizationAccountAccessRole" \
            --role-session-name "github-actions-test-ec2" \
            --duration-seconds 3600 \
            --output json)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          
          # Verify we're in the member account
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "‚úÖ Assumed role in account: $ACCOUNT_ID"
          
          if [ "$ACCOUNT_ID" != "${{ env.MEMBER_ACCOUNT_ID }}" ]; then
            echo "::error::Failed to assume role in member account"
            exit 1
          fi
      
      - name: Get latest AMI
        id: ami
        run: |
          # Get latest Amazon Linux 2023 AMI
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters "Name=name,Values=al2023-ami-*-x86_64" \
                      "Name=state,Values=available" \
            --query "Images | sort_by(@, &CreationDate) | [-1].ImageId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Using AMI: $AMI_ID"
      
      - name: Create VPC and Security Group
        id: vpc
        run: |
          echo "üåê Creating VPC and security group..."
          
          # Create VPC
          VPC_ID=$(aws ec2 create-vpc \
            --cidr-block 10.0.0.0/16 \
            --tag-specifications "ResourceType=vpc,Tags=[{Key=Name,Value=custodian-test-vpc}]" \
            --query 'Vpc.VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created VPC: $VPC_ID"
          
          # Create Internet Gateway
          IGW_ID=$(aws ec2 create-internet-gateway \
            --tag-specifications "ResourceType=internet-gateway,Tags=[{Key=Name,Value=custodian-test-igw}]" \
            --query 'InternetGateway.InternetGatewayId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "igw_id=$IGW_ID" >> $GITHUB_OUTPUT
          
          # Attach IGW to VPC
          aws ec2 attach-internet-gateway \
            --vpc-id $VPC_ID \
            --internet-gateway-id $IGW_ID \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Attached IGW: $IGW_ID"
          
          # Create Subnet
          SUBNET_ID=$(aws ec2 create-subnet \
            --vpc-id $VPC_ID \
            --cidr-block 10.0.1.0/24 \
            --tag-specifications "ResourceType=subnet,Tags=[{Key=Name,Value=custodian-test-subnet}]" \
            --query 'Subnet.SubnetId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created Subnet: $SUBNET_ID"
          
          # Enable auto-assign public IP
          aws ec2 modify-subnet-attribute \
            --subnet-id $SUBNET_ID \
            --map-public-ip-on-launch \
            --region ${{ env.AWS_REGION }}
          
          # Create route table
          RT_ID=$(aws ec2 create-route-table \
            --vpc-id $VPC_ID \
            --tag-specifications "ResourceType=route-table,Tags=[{Key=Name,Value=custodian-test-rt}]" \
            --query 'RouteTable.RouteTableId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "rt_id=$RT_ID" >> $GITHUB_OUTPUT
          
          # Create route to IGW
          aws ec2 create-route \
            --route-table-id $RT_ID \
            --destination-cidr-block 0.0.0.0/0 \
            --gateway-id $IGW_ID \
            --region ${{ env.AWS_REGION }}
          
          # Associate route table with subnet
          aws ec2 associate-route-table \
            --route-table-id $RT_ID \
            --subnet-id $SUBNET_ID \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Configured routing"
          
          # Create Security Group with public access (0.0.0.0/0)
          SG_ID=$(aws ec2 create-security-group \
            --group-name custodian-test-sg \
            --description "Test security group for Cloud Custodian" \
            --vpc-id $VPC_ID \
            --tag-specifications "ResourceType=security-group,Tags=[{Key=Name,Value=custodian-test-sg}]" \
            --query 'GroupId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "sg_id=$SG_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created Security Group: $SG_ID"
          
          # Add ingress rule - SSH from anywhere (0.0.0.0/0)
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 22 \
            --cidr 0.0.0.0/0 \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Added public SSH rule (0.0.0.0/0)"
      
      - name: Create EC2 instance with non-encrypted boot volume
        id: create
        run: |
          echo "üöÄ Launching EC2 instance with non-encrypted boot volume..."
          
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ${{ steps.ami.outputs.ami_id }} \
            --instance-type t3.micro \
            --subnet-id ${{ steps.vpc.outputs.subnet_id }} \
            --security-group-ids ${{ steps.vpc.outputs.sg_id }} \
            --associate-public-ip-address \
            --block-device-mappings "[{\"DeviceName\":\"/dev/xvda\",\"Ebs\":{\"VolumeSize\":8,\"VolumeType\":\"gp3\",\"DeleteOnTermination\":true,\"Encrypted\":false}}]" \
            --metadata-options "HttpTokens=optional,HttpPutResponseHopLimit=1" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=custodian-test-instance},{Key=Environment,Value=test},{Key=CustodianTest,Value=true}]" \
            --query 'Instances[0].InstanceId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created EC2 instance: $INSTANCE_ID"
          
          # Wait for instance to be running
          echo "‚è≥ Waiting for instance to be running..."
          aws ec2 wait instance-running \
            --instance-ids $INSTANCE_ID \
            --region ${{ env.AWS_REGION }}
          
          # Get instance details
          aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].{InstanceId:InstanceId,State:State.Name,PublicIP:PublicIpAddress,PrivateIP:PrivateIpAddress}' \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Instance is running"
      
      - name: Create and attach non-encrypted EBS volume
        id: attach
        run: |
          echo "üíæ Creating non-encrypted EBS volume..."
          
          # Get instance availability zone
          AZ=$(aws ec2 describe-instances \
            --instance-ids ${{ steps.create.outputs.instance_id }} \
            --query 'Reservations[0].Instances[0].Placement.AvailabilityZone' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "Availability Zone: $AZ"
          
          # Create unencrypted volume
          VOLUME_ID=$(aws ec2 create-volume \
            --availability-zone $AZ \
            --size 10 \
            --volume-type gp3 \
            --encrypted false \
            --tag-specifications "ResourceType=volume,Tags=[{Key=Name,Value=custodian-test-volume},{Key=Environment,Value=test},{Key=CustodianTest,Value=true}]" \
            --query 'VolumeId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "volume_id=$VOLUME_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created volume: $VOLUME_ID"
          
          # Wait for volume to be available
          echo "‚è≥ Waiting for volume to be available..."
          aws ec2 wait volume-available \
            --volume-ids $VOLUME_ID \
            --region ${{ env.AWS_REGION }}
          
          # Attach volume to instance
          aws ec2 attach-volume \
            --volume-id $VOLUME_ID \
            --instance-id ${{ steps.create.outputs.instance_id }} \
            --device /dev/sdf \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Attached volume to instance"
          
          # Wait for attachment
          sleep 5
          
          # Verify attachment
          aws ec2 describe-volumes \
            --volume-ids $VOLUME_ID \
            --query 'Volumes[0].{VolumeId:VolumeId,State:State,Encrypted:Encrypted,Attachments:Attachments}' \
            --region ${{ env.AWS_REGION }}
      
      - name: Summary
        run: |
          cat <<EOF
          
          ========================================
          üéâ Test Resources Created Successfully!
          ========================================
          
          EC2 Instance ID: ${{ steps.create.outputs.instance_id }}
          EBS Volume ID: ${{ steps.attach.outputs.volume_id }}
          VPC ID: ${{ steps.vpc.outputs.vpc_id }}
          Security Group ID: ${{ steps.vpc.outputs.sg_id }}
          
          ‚ö†Ô∏è  Test Configuration:
          - ‚úÖ Public IP assigned
          - ‚úÖ Security group allows 0.0.0.0/0
          - ‚úÖ Boot volume: NON-ENCRYPTED
          - ‚úÖ Additional EBS volume: NON-ENCRYPTED
          - ‚úÖ IMDSv1 enabled (HttpTokens=optional)
          
          These resources will trigger Cloud Custodian policies!
          
          EOF

  # ======================================================================
  # Job 3: Dry Run Policy (No Actions Executed)
  # ======================================================================
  dry-run-policy:
    name: Dry Run - ${{ inputs.policy_file }}
    runs-on: ubuntu-latest
    needs: validate-policy
    if: inputs.test_action == 'dry-run' || inputs.test_action == 'live-test'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Option 1: OIDC (Recommended)
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Cloud Custodian
        run: |
          pip install c7n c7n-org pyyaml boto3
          custodian version
      
      - name: Run policy in dry-run mode
        id: dryrun
        run: |
          echo "üß™ Running policy in dry-run mode (no actions executed)..."
          
          POLICY_PATH="policies/${{ inputs.policy_file }}"
          OUTPUT_DIR="test-output/$(date +%Y%m%d-%H%M%S)"
          
          mkdir -p "$OUTPUT_DIR"
          
          # Run in dry-run mode
          custodian run \
            -s "$OUTPUT_DIR" \
            --region ${{ env.AWS_REGION }} \
            --dryrun \
            "$POLICY_PATH" 2>&1 | tee dryrun-output.log
          
          echo "‚úÖ Dry-run completed!"
      
      - name: Analyze dry-run results
        run: |
          echo "üìä Analyzing dry-run results..."
          
          OUTPUT_DIR="test-output"
          
          # Find the latest output directory
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          echo "Results directory: $LATEST_DIR"
          ls -la "$LATEST_DIR" || echo "No output directory found"
          
          # Check for resources.json in subdirectories
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              echo ""
              echo "Policy: $POLICY_NAME"
              
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "  Resources matched: $RESOURCE_COUNT"
                
                if [ "$RESOURCE_COUNT" -gt 0 ]; then
                  echo "  Sample resources:"
                  jq -r '.[] | .Name // .id // .Id // .InstanceId // .BucketName // "Unknown"' "$policy_dir/resources.json" | head -10
                fi
              else
                echo "  No resources.json found"
              fi
            fi
          done
      
      - name: Generate dry-run report
        run: |
          OUTPUT_DIR="test-output"
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          cat <<EOF > dryrun-report.md
          ## üß™ Policy Dry-Run Report
          
          **Policy File:** \`${{ inputs.policy_file }}\`
          **Execution Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **AWS Region:** ${{ env.AWS_REGION }}
          **Mode:** Dry-Run (No actions executed)
          
          ### Execution Summary
          
          EOF
          
          # Add resource counts per policy
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "- **$POLICY_NAME**: $RESOURCE_COUNT resources matched" >> dryrun-report.md
              fi
            fi
          done
          
          cat <<EOF >> dryrun-report.md
          
          ### Important Notes
          
          - ‚ö†Ô∏è This was a **DRY-RUN** - no actions were executed
          - Resources listed above would be affected in a live run
          - Review the matched resources before live execution
          
          ### Next Steps
          
          1. Review matched resources
          2. Adjust filters if needed
          3. Test with live-test action (caution!)
          4. Deploy to Lambda for scheduled execution
          
          EOF
          
          cat dryrun-report.md
      
      - name: Upload dry-run artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dryrun-results-${{ inputs.policy_file }}
          path: |
            test-output/
            dryrun-output.log
            dryrun-report.md
          retention-days: 30

  # ======================================================================
  # Job 4: Live Test (Execute Actions - USE WITH CAUTION!)
  # ======================================================================
  live-test-policy:
    name: Live Test - ${{ inputs.policy_file }}
    runs-on: ubuntu-latest
    needs: [validate-policy, dry-run-policy, create-test-ec2]
    if: inputs.test_action == 'live-test'
    environment:
      name: ${{ inputs.environment }}-policy-test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Option 1: OIDC (Recommended)
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Cloud Custodian
        run: |
          pip install c7n c7n-org pyyaml boto3
          custodian version
      
      - name: Warning banner
        run: |
          echo "::warning::‚ö†Ô∏è LIVE TEST MODE - Actions will be EXECUTED!"
          echo "::warning::This will make REAL changes to AWS resources!"
          sleep 5
      
      - name: Run policy in live mode
        id: live
        run: |
          echo "üö® Running policy in LIVE mode..."
          
          POLICY_PATH="policies/${{ inputs.policy_file }}"
          OUTPUT_DIR="live-output/$(date +%Y%m%d-%H%M%S)"
          
          mkdir -p "$OUTPUT_DIR"
          
          # Run in live mode (actions will be executed!)
          custodian run \
            -s "$OUTPUT_DIR" \
            --region ${{ env.AWS_REGION }} \
            "$POLICY_PATH" 2>&1 | tee live-output.log
          
          echo "‚úÖ Live execution completed!"
      
      - name: Analyze live results
        run: |
          echo "üìä Analyzing live execution results..."
          
          OUTPUT_DIR="live-output"
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              echo ""
              echo "Policy: $POLICY_NAME"
              
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "  Resources processed: $RESOURCE_COUNT"
              fi
              
              if [ -f "$policy_dir/action.log" ]; then
                echo "  Action log:"
                cat "$policy_dir/action.log"
              fi
            fi
          done
      
      - name: Generate live test report
        run: |
          OUTPUT_DIR="live-output"
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          cat <<EOF > live-test-report.md
          ## üö® Live Policy Execution Report
          
          **Policy File:** \`${{ inputs.policy_file }}\`
          **Execution Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Environment:** ${{ inputs.environment }}
          **AWS Region:** ${{ env.AWS_REGION }}
          **Mode:** LIVE (Actions EXECUTED)
          
          ### ‚ö†Ô∏è WARNING
          
          This was a **LIVE EXECUTION** - actions were performed on real AWS resources!
          
          ### Execution Summary
          
          EOF
          
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "- **$POLICY_NAME**: $RESOURCE_COUNT resources processed" >> live-test-report.md
              fi
            fi
          done
          
          cat <<EOF >> live-test-report.md
          
          ### Actions Taken
          
          Review the action logs and CloudWatch Logs for detailed information about actions performed.
          
          ### Next Steps
          
          1. Verify changes in AWS Console
          2. Check CloudWatch Logs for detailed execution
          3. Review any errors or warnings
          4. Adjust policy if needed
          5. Deploy to production Lambda
          
          EOF
          
          cat live-test-report.md
      
      - name: Upload live test artifacts
        uses: actions/upload-artifact@v4
        with:
          name: live-test-results-${{ inputs.policy_file }}
          path: |
            live-output/
            live-output.log
            live-test-report.md
          retention-days: 90

      - name: Send notification
        run: |
          echo "::notice::‚úÖ Live policy test completed for ${{ inputs.policy_file }}"
          echo "::notice::Review artifacts and CloudWatch Logs for details"

  # ======================================================================
  # Job 5: Test Lambda Integration
  # ======================================================================
  test-lambda-integration:
    name: Test Lambda Integration
    runs-on: ubuntu-latest
    needs: validate-policy
    if: inputs.test_action == 'live-test'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Option 1: OIDC (Recommended)
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Find Lambda function
        id: lambda
        run: |
          # Try to find Lambda function by name pattern
          FUNCTION_NAME=$(aws lambda list-functions \
            --query "Functions[?contains(FunctionName, 'custodian')].FunctionName | [0]" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ -z "$FUNCTION_NAME" ] || [ "$FUNCTION_NAME" == "None" ]; then
            echo "::warning::No Cloud Custodian Lambda function found"
            echo "found=false" >> $GITHUB_OUTPUT
          else
            echo "found=true" >> $GITHUB_OUTPUT
            echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT
            echo "‚úÖ Found Lambda function: $FUNCTION_NAME"
          fi
      
      - name: Test Lambda with policy
        if: steps.lambda.outputs.found == 'true'
        run: |
          echo "üß™ Testing Lambda function with policy..."
          
          PAYLOAD=$(cat <<EOF
          {
            "policy_source": "file",
            "policy_path": "/var/task/policies/${{ inputs.policy_file }}",
            "dryrun": true,
            "region": "${{ env.AWS_REGION }}"
          }
          EOF
          )
          
          aws lambda invoke \
            --function-name ${{ steps.lambda.outputs.function_name }} \
            --payload "$PAYLOAD" \
            --log-type Tail \
            --region ${{ env.AWS_REGION }} \
            lambda-response.json
          
          echo "Lambda response:"
          cat lambda-response.json | jq .
          
          echo "‚úÖ Lambda integration test completed!"
      
      - name: Check CloudWatch Logs
        if: steps.lambda.outputs.found == 'true'
        run: |
          echo "üìã Checking Lambda CloudWatch Logs..."
          
          LOG_GROUP="/aws/lambda/${{ steps.lambda.outputs.function_name }}"
          
          aws logs tail "$LOG_GROUP" \
            --since 5m \
            --format short \
            --region ${{ env.AWS_REGION }} || echo "No recent logs found"

  # ======================================================================
  # Job 6: Cleanup Test Resources
  # ======================================================================
  cleanup-test-resources:
    name: Cleanup Test Resources
    runs-on: ubuntu-latest
    needs: [create-test-ec2, live-test-policy]
    if: always() && inputs.test_action == 'live-test'
    
    steps:
      - name: Configure AWS credentials (Central Account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.CENTRAL_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Assume role in Member Account
        run: |
          echo "üîê Assuming OrganizationAccountAccessRole in member account..."
          
          CREDENTIALS=$(aws sts assume-role \
            --role-arn "arn:aws:iam::${{ env.MEMBER_ACCOUNT_ID }}:role/OrganizationAccountAccessRole" \
            --role-session-name "github-actions-cleanup" \
            --duration-seconds 3600 \
            --output json)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          
          # Verify we're in the member account
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "‚úÖ Assumed role in account: $ACCOUNT_ID"
      
      - name: Cleanup EC2 instance
        if: needs.create-test-ec2.outputs.instance_id != ''
        run: |
          echo "üßπ Cleaning up EC2 instance..."
          
          INSTANCE_ID="${{ needs.create-test-ec2.outputs.instance_id }}"
          
          if [ -n "$INSTANCE_ID" ]; then
            # Terminate instance
            aws ec2 terminate-instances \
              --instance-ids $INSTANCE_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to terminate instance"
            
            echo "‚è≥ Waiting for instance to terminate..."
            aws ec2 wait instance-terminated \
              --instance-ids $INSTANCE_ID \
              --region ${{ env.AWS_REGION }} || echo "Wait timeout"
            
            echo "‚úÖ Instance terminated"
          fi
      
      - name: Cleanup EBS volume
        if: needs.create-test-ec2.outputs.volume_id != ''
        run: |
          echo "üßπ Cleaning up EBS volume..."
          
          VOLUME_ID="${{ needs.create-test-ec2.outputs.volume_id }}"
          
          if [ -n "$VOLUME_ID" ]; then
            # Wait a bit for volume to detach
            sleep 10
            
            # Delete volume
            aws ec2 delete-volume \
              --volume-id $VOLUME_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to delete volume (may already be deleted)"
            
            echo "‚úÖ Volume deleted"
          fi
      
      - name: Cleanup VPC resources
        run: |
          echo "üßπ Cleaning up VPC and networking resources..."
          
          # Find test VPC
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=custodian-test-vpc" \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$VPC_ID" != "None" ] && [ -n "$VPC_ID" ]; then
            echo "Found VPC: $VPC_ID"
            
            # Delete security groups (except default)
            SG_IDS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for SG_ID in $SG_IDS; do
              echo "Deleting security group: $SG_ID"
              aws ec2 delete-security-group \
                --group-id $SG_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete SG"
            done
            
            # Delete subnets
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[].SubnetId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for SUBNET_ID in $SUBNET_IDS; do
              echo "Deleting subnet: $SUBNET_ID"
              aws ec2 delete-subnet \
                --subnet-id $SUBNET_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete subnet"
            done
            
            # Detach and delete internet gateways
            IGW_IDS=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[].InternetGatewayId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for IGW_ID in $IGW_IDS; do
              echo "Detaching and deleting IGW: $IGW_ID"
              aws ec2 detach-internet-gateway \
                --internet-gateway-id $IGW_ID \
                --vpc-id $VPC_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to detach IGW"
              aws ec2 delete-internet-gateway \
                --internet-gateway-id $IGW_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete IGW"
            done
            
            # Delete route tables (except main)
            RT_IDS=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for RT_ID in $RT_IDS; do
              echo "Deleting route table: $RT_ID"
              aws ec2 delete-route-table \
                --route-table-id $RT_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete route table"
            done
            
            # Finally delete VPC
            echo "Deleting VPC: $VPC_ID"
            aws ec2 delete-vpc \
              --vpc-id $VPC_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to delete VPC"
            
            echo "‚úÖ VPC cleanup completed"
          else
            echo "No test VPC found to clean up"
          fi
      
      - name: Cleanup summary
        run: |
          echo "‚úÖ Cleanup completed!"
          echo "All test resources have been removed."
