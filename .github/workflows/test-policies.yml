name: Test Cloud Custodian Policies

on:
  workflow_dispatch:
    inputs:
      policies_to_test:
        description: 'Select EC2 policies to test'
        required: true
        type: choice
        options:
          - all
          - ami-publicly-accessible
          - ebs-snapshot-unencrypted
          - ebs-snapshot-public
          - ec2-unencrypted-ebs-volume
          - ec2-imdsv1-enabled
          - ec2-stop-instances-on-launch
        default: 'all'
      test_action:
        description: 'Test action to perform'
        required: true
        type: choice
        options:
          - validate-only
          - dry-run
          - live-test
        default: 'validate-only'

env:
  AWS_REGION: us-east-1
  PYTHON_VERSION: "3.11"
  MEMBER_ACCOUNT_ID: "813185901390"
  CENTRAL_ACCOUNT_ID: "172327596604"

permissions:
  id-token: write
  contents: read

jobs:
  # ======================================================================
  # Job 1: Validate Policy Syntax
  # ======================================================================
  validate-policy:
    name: Validate Policy - aws-ec2-security.yml
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Cloud Custodian
        run: |
          pip install c7n c7n-org pyyaml boto3
          echo "Cloud Custodian version:"
          custodian version
      
      - name: Validate YAML syntax
        run: |
          echo "üîç Validating YAML syntax..."
          
          POLICY_PATH="c7n/policies/aws-ec2-security.yml"
          
          if [ ! -f "$POLICY_PATH" ]; then
            echo "::error::Policy file not found: $POLICY_PATH"
            exit 1
          fi
          
          # Validate YAML syntax
          python -c "import yaml; yaml.safe_load(open('$POLICY_PATH'))"
          echo "‚úÖ YAML syntax is valid"
      
      - name: Validate Cloud Custodian policy
        run: |
          echo "üîç Validating Cloud Custodian policy..."
          
          POLICY_PATH="c7n/policies/aws-ec2-security.yml"
          
          # Validate policy structure
          custodian validate "$POLICY_PATH"
          echo "‚úÖ Policy validation successful!"
      
      - name: Extract selected policy details
        run: |
          echo "üìä Analyzing selected policy: ${{ inputs.policies_to_test }}"
          
          POLICY_PATH="c7n/policies/aws-ec2-security.yml"
          SELECTED_POLICY="${{ inputs.policies_to_test }}"
          
          if [ "$SELECTED_POLICY" == "all" ]; then
            echo "Testing ALL policies in file:"
            python <<EOF
          import yaml
          with open('$POLICY_PATH') as f:
              data = yaml.safe_load(f)
              for policy in data.get('policies', []):
                  print(f"  - {policy['name']}: {policy['resource']}")
          EOF
          else
            echo "Testing SINGLE policy: $SELECTED_POLICY"
            python <<EOF
          import yaml
          with open('$POLICY_PATH') as f:
              data = yaml.safe_load(f)
              for policy in data.get('policies', []):
                  if policy['name'] == '$SELECTED_POLICY':
                      print(f"  - Name: {policy['name']}")
                      print(f"  - Resource: {policy['resource']}")
                      print(f"  - Filters: {len(policy.get('filters', []))}")
                      print(f"  - Actions: {len(policy.get('actions', []))}")
                      break
          EOF
          fi
      
      - name: Generate validation report
        run: |
          cat <<EOF > validation-report.md
          ## ‚úÖ Policy Validation Report
          
          **Policy File:** \`aws-ec2-security.yml\`
          **Selected Policy:** \`${{ inputs.policies_to_test }}\`
          **Test Action:** \`${{ inputs.test_action }}\`
          **Validation Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Triggered by:** ${{ github.actor }}
          **Target Account:** Member Account (${{ env.MEMBER_ACCOUNT_ID }})
          
          ### Validation Results
          
          - ‚úÖ YAML syntax: PASSED
          - ‚úÖ Cloud Custodian schema: PASSED
          - ‚úÖ Policy structure: VALID
          
          EOF
          
          cat validation-report.md
      
      - name: Upload validation report
        uses: actions/upload-artifact@v4
        with:
          name: validation-report-ec2-security
          path: validation-report.md
          retention-days: 30

  # ======================================================================
  # Job 2: Create Test EC2 Instance
  # ======================================================================
  create-test-ec2:
    name: Create Test Resources - ${{ inputs.policies_to_test }}
    runs-on: ubuntu-latest
    needs: validate-policy
    if: inputs.test_action == 'live-test'
    
    outputs:
      instance_id: ${{ steps.create.outputs.instance_id }}
      volume_id: ${{ steps.attach.outputs.volume_id }}
      ami_id: ${{ steps.create_ami.outputs.ami_id }}
      snapshot_id: ${{ steps.create_snapshot.outputs.snapshot_id }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials (Central Account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.CENTRAL_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Assume role in Member Account
        run: |
          echo "üîê Assuming OrganizationAccountAccessRole in member account..."
          
          CREDENTIALS=$(aws sts assume-role \
            --role-arn "arn:aws:iam::${{ env.MEMBER_ACCOUNT_ID }}:role/OrganizationAccountAccessRole" \
            --role-session-name "github-actions-test-ec2" \
            --duration-seconds 3600 \
            --output json)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          
          # Verify we're in the member account
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "‚úÖ Assumed role in account: $ACCOUNT_ID"
          
          if [ "$ACCOUNT_ID" != "${{ env.MEMBER_ACCOUNT_ID }}" ]; then
            echo "::error::Failed to assume role in member account"
            exit 1
          fi
      
      - name: Get latest AMI
        id: ami
        run: |
          # Get latest Amazon Linux 2023 AMI
          AMI_ID=$(aws ec2 describe-images \
            --owners amazon \
            --filters "Name=name,Values=al2023-ami-*-x86_64" \
                      "Name=state,Values=available" \
            --query "Images | sort_by(@, &CreationDate) | [-1].ImageId" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Using AMI: $AMI_ID"
      
      - name: Create VPC and Security Group
        id: vpc
        run: |
          echo "üåê Creating VPC and security group..."
          
          # Create VPC
          VPC_ID=$(aws ec2 create-vpc \
            --cidr-block 10.0.0.0/16 \
            --tag-specifications "ResourceType=vpc,Tags=[{Key=Name,Value=custodian-test-vpc}]" \
            --query 'Vpc.VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "vpc_id=$VPC_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created VPC: $VPC_ID"
          
          # Create Internet Gateway
          IGW_ID=$(aws ec2 create-internet-gateway \
            --tag-specifications "ResourceType=internet-gateway,Tags=[{Key=Name,Value=custodian-test-igw}]" \
            --query 'InternetGateway.InternetGatewayId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "igw_id=$IGW_ID" >> $GITHUB_OUTPUT
          
          # Attach IGW to VPC
          aws ec2 attach-internet-gateway \
            --vpc-id $VPC_ID \
            --internet-gateway-id $IGW_ID \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Attached IGW: $IGW_ID"
          
          # Create Subnet
          SUBNET_ID=$(aws ec2 create-subnet \
            --vpc-id $VPC_ID \
            --cidr-block 10.0.1.0/24 \
            --tag-specifications "ResourceType=subnet,Tags=[{Key=Name,Value=custodian-test-subnet}]" \
            --query 'Subnet.SubnetId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "subnet_id=$SUBNET_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created Subnet: $SUBNET_ID"
          
          # Enable auto-assign public IP
          aws ec2 modify-subnet-attribute \
            --subnet-id $SUBNET_ID \
            --map-public-ip-on-launch \
            --region ${{ env.AWS_REGION }}
          
          # Create route table
          RT_ID=$(aws ec2 create-route-table \
            --vpc-id $VPC_ID \
            --tag-specifications "ResourceType=route-table,Tags=[{Key=Name,Value=custodian-test-rt}]" \
            --query 'RouteTable.RouteTableId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "rt_id=$RT_ID" >> $GITHUB_OUTPUT
          
          # Create route to IGW
          aws ec2 create-route \
            --route-table-id $RT_ID \
            --destination-cidr-block 0.0.0.0/0 \
            --gateway-id $IGW_ID \
            --region ${{ env.AWS_REGION }}
          
          # Associate route table with subnet
          aws ec2 associate-route-table \
            --route-table-id $RT_ID \
            --subnet-id $SUBNET_ID \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Configured routing"
          
          # Create Security Group with public access (0.0.0.0/0)
          SG_ID=$(aws ec2 create-security-group \
            --group-name custodian-test-sg \
            --description "Test security group for Cloud Custodian" \
            --vpc-id $VPC_ID \
            --tag-specifications "ResourceType=security-group,Tags=[{Key=Name,Value=custodian-test-sg}]" \
            --query 'GroupId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "sg_id=$SG_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created Security Group: $SG_ID"
          
          # Add ingress rule - SSH from anywhere (0.0.0.0/0)
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 22 \
            --cidr 0.0.0.0/0 \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Added public SSH rule (0.0.0.0/0)"
      
      - name: Create EC2 instance with non-encrypted boot volume
        id: create
        if: |
          inputs.policies_to_test == 'all' ||
          inputs.policies_to_test == 'ec2-unencrypted-ebs-volume' ||
          inputs.policies_to_test == 'ec2-imdsv1-enabled' ||
          inputs.policies_to_test == 'ec2-stop-instances-on-launch'
        run: |
          echo "üöÄ Launching EC2 instance for policy: ${{ inputs.policies_to_test }}..."
          
          # Determine IMDSv1 setting based on policy
          if [ "${{ inputs.policies_to_test }}" == "ec2-imdsv1-enabled" ] || [ "${{ inputs.policies_to_test }}" == "all" ]; then
            IMDS_TOKENS="optional"
            echo "Setting IMDSv1 enabled (HttpTokens=optional)"
          else
            IMDS_TOKENS="required"
            echo "Setting IMDSv2 only (HttpTokens=required)"
          fi
          
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ${{ steps.ami.outputs.ami_id }} \
            --instance-type t3.micro \
            --subnet-id ${{ steps.vpc.outputs.subnet_id }} \
            --security-group-ids ${{ steps.vpc.outputs.sg_id }} \
            --associate-public-ip-address \
            --block-device-mappings "[{\"DeviceName\":\"/dev/xvda\",\"Ebs\":{\"VolumeSize\":8,\"VolumeType\":\"gp3\",\"DeleteOnTermination\":true,\"Encrypted\":false}}]" \
            --metadata-options "HttpTokens=$IMDS_TOKENS,HttpPutResponseHopLimit=1" \
            --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=custodian-test-${{ inputs.policies_to_test }}},{Key=Environment,Value=test},{Key=CustodianTest,Value=true},{Key=Policy,Value=${{ inputs.policies_to_test }}}]" \
            --query 'Instances[0].InstanceId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created EC2 instance: $INSTANCE_ID"
          
          # Wait for instance to be running
          echo "‚è≥ Waiting for instance to be running..."
          aws ec2 wait instance-running \
            --instance-ids $INSTANCE_ID \
            --region ${{ env.AWS_REGION }}
          
          # Get instance details
          aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].{InstanceId:InstanceId,State:State.Name,PublicIP:PublicIpAddress,PrivateIP:PrivateIpAddress,IMDSv2:MetadataOptions.HttpTokens}' \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Instance is running"
      
      - name: Create and attach non-encrypted EBS volume
        id: attach
        if: |
          inputs.policies_to_test == 'all' ||
          inputs.policies_to_test == 'ec2-unencrypted-ebs-volume'
        run: |
          echo "üíæ Creating non-encrypted EBS volume for policy: ${{ inputs.policies_to_test }}..."
          
          # Check if instance was created
          INSTANCE_ID="${{ steps.create.outputs.instance_id }}"
          if [ -z "$INSTANCE_ID" ]; then
            echo "::warning::No instance created, skipping volume creation"
            exit 0
          fi
          
          # Get instance availability zone
          AZ=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].Placement.AvailabilityZone' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "Availability Zone: $AZ"
          
          # Create unencrypted volume
          VOLUME_ID=$(aws ec2 create-volume \
            --availability-zone $AZ \
            --size 10 \
            --volume-type gp3 \
            --encrypted false \
            --tag-specifications "ResourceType=volume,Tags=[{Key=Name,Value=custodian-test-volume-${{ inputs.policies_to_test }}},{Key=Environment,Value=test},{Key=CustodianTest,Value=true},{Key=Policy,Value=${{ inputs.policies_to_test }}}]" \
            --query 'VolumeId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "volume_id=$VOLUME_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created volume: $VOLUME_ID"
          
          # Wait for volume to be available
          echo "‚è≥ Waiting for volume to be available..."
          aws ec2 wait volume-available \
            --volume-ids $VOLUME_ID \
            --region ${{ env.AWS_REGION }}
          
          # Attach volume to instance
          aws ec2 attach-volume \
            --volume-id $VOLUME_ID \
            --instance-id $INSTANCE_ID \
            --device /dev/sdf \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ Attached volume to instance"
          
          # Wait for attachment
          sleep 5
          
          # Verify attachment
          aws ec2 describe-volumes \
            --volume-ids $VOLUME_ID \
            --query 'Volumes[0].{VolumeId:VolumeId,State:State,Encrypted:Encrypted,Attachments:Attachments}' \
            --region ${{ env.AWS_REGION }}
      
      - name: Create public AMI
        id: create_ami
        if: |
          inputs.policies_to_test == 'all' ||
          inputs.policies_to_test == 'ami-publicly-accessible'
        run: |
          echo "üì∏ Creating public AMI for policy: ${{ inputs.policies_to_test }}..."
          
          # Use an existing instance or create a temporary one
          INSTANCE_ID="${{ steps.create.outputs.instance_id }}"
          TEMP_INSTANCE=false
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "No instance available, creating temporary instance for AMI..."
            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id ${{ steps.ami.outputs.ami_id }} \
              --instance-type t3.micro \
              --subnet-id ${{ steps.vpc.outputs.subnet_id }} \
              --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=temp-ami-instance},{Key=Temporary,Value=true}]" \
              --query 'Instances[0].InstanceId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            TEMP_INSTANCE=true
            echo "temp_instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
            
            # Wait for instance
            aws ec2 wait instance-running \
              --instance-ids $INSTANCE_ID \
              --region ${{ env.AWS_REGION }}
          fi
          
          # Create AMI
          AMI_ID=$(aws ec2 create-image \
            --instance-id $INSTANCE_ID \
            --name "custodian-test-ami-${{ github.run_number }}" \
            --description "Test AMI for Cloud Custodian policy testing" \
            --no-reboot \
            --tag-specifications "ResourceType=image,Tags=[{Key=Name,Value=custodian-test-ami},{Key=CustodianTest,Value=true},{Key=Policy,Value=${{ inputs.policies_to_test }}}]" \
            --query 'ImageId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created AMI: $AMI_ID"
          
          # Wait for AMI to be available
          echo "‚è≥ Waiting for AMI to be available..."
          aws ec2 wait image-available \
            --image-ids $AMI_ID \
            --region ${{ env.AWS_REGION }}
          
          # Make AMI public
          echo "üåê Making AMI publicly accessible..."
          aws ec2 modify-image-attribute \
            --image-id $AMI_ID \
            --launch-permission "Add=[{Group=all}]" \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ AMI is now public"
          
          # Terminate temporary instance if created
          if [ "$TEMP_INSTANCE" == "true" ]; then
            echo "Terminating temporary instance..."
            aws ec2 terminate-instances \
              --instance-ids $INSTANCE_ID \
              --region ${{ env.AWS_REGION }}
          fi
      
      - name: Create unencrypted EBS snapshot
        id: create_snapshot
        if: |
          inputs.policies_to_test == 'all' ||
          inputs.policies_to_test == 'ebs-snapshot-unencrypted' ||
          inputs.policies_to_test == 'ebs-snapshot-public'
        run: |
          echo "üì∏ Creating unencrypted EBS snapshot for policy: ${{ inputs.policies_to_test }}..."
          
          # Get or create a volume
          VOLUME_ID="${{ steps.attach.outputs.volume_id }}"
          TEMP_VOLUME=false
          
          if [ -z "$VOLUME_ID" ]; then
            echo "No volume available, creating temporary volume for snapshot..."
            
            # Get first AZ in region
            AZ=$(aws ec2 describe-availability-zones \
              --query 'AvailabilityZones[0].ZoneName' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            VOLUME_ID=$(aws ec2 create-volume \
              --availability-zone $AZ \
              --size 1 \
              --volume-type gp3 \
              --encrypted false \
              --tag-specifications "ResourceType=volume,Tags=[{Key=Name,Value=temp-snapshot-volume},{Key=Temporary,Value=true}]" \
              --query 'VolumeId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            TEMP_VOLUME=true
            echo "temp_volume_id=$VOLUME_ID" >> $GITHUB_OUTPUT
            
            # Wait for volume
            aws ec2 wait volume-available \
              --volume-ids $VOLUME_ID \
              --region ${{ env.AWS_REGION }}
          fi
          
          # Create snapshot
          SNAPSHOT_ID=$(aws ec2 create-snapshot \
            --volume-id $VOLUME_ID \
            --description "Test snapshot for Cloud Custodian policy testing" \
            --tag-specifications "ResourceType=snapshot,Tags=[{Key=Name,Value=custodian-test-snapshot},{Key=CustodianTest,Value=true},{Key=Policy,Value=${{ inputs.policies_to_test }}}]" \
            --query 'SnapshotId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          echo "snapshot_id=$SNAPSHOT_ID" >> $GITHUB_OUTPUT
          echo "‚úÖ Created snapshot: $SNAPSHOT_ID"
          
          # Wait for snapshot to complete
          echo "‚è≥ Waiting for snapshot to complete (this may take a few minutes)..."
          aws ec2 wait snapshot-completed \
            --snapshot-ids $SNAPSHOT_ID \
            --region ${{ env.AWS_REGION }}
          
          # Make snapshot public if testing public snapshot policy
          if [ "${{ inputs.policies_to_test }}" == "ebs-snapshot-public" ] || [ "${{ inputs.policies_to_test }}" == "all" ]; then
            echo "üåê Making snapshot publicly accessible..."
            aws ec2 modify-snapshot-attribute \
              --snapshot-id $SNAPSHOT_ID \
              --attribute createVolumePermission \
              --operation-type add \
              --group-names all \
              --region ${{ env.AWS_REGION }}
            echo "‚úÖ Snapshot is now public"
          fi
          
          # Delete temporary volume if created
          if [ "$TEMP_VOLUME" == "true" ]; then
            echo "Deleting temporary volume..."
            aws ec2 delete-volume \
              --volume-id $VOLUME_ID \
              --region ${{ env.AWS_REGION }}
          fi
      
      - name: Summary
        run: |
          cat <<EOF
          
          ========================================
          üéâ Test Resources Created Successfully!
          ========================================
          
          Policy Being Tested: ${{ inputs.policies_to_test }}
          Target Account: Member Account (${{ env.MEMBER_ACCOUNT_ID }})
          
          Resources Created:
          EOF
          
          if [ -n "${{ steps.create.outputs.instance_id }}" ]; then
            echo "  ‚úÖ EC2 Instance: ${{ steps.create.outputs.instance_id }}"
          fi
          
          if [ -n "${{ steps.attach.outputs.volume_id }}" ]; then
            echo "  ‚úÖ EBS Volume: ${{ steps.attach.outputs.volume_id }}"
          fi
          
          if [ -n "${{ steps.create_ami.outputs.ami_id }}" ]; then
            echo "  ‚úÖ Public AMI: ${{ steps.create_ami.outputs.ami_id }}"
          fi
          
          if [ -n "${{ steps.create_snapshot.outputs.snapshot_id }}" ]; then
            echo "  ‚úÖ EBS Snapshot: ${{ steps.create_snapshot.outputs.snapshot_id }}"
          fi
          
          echo ""
          echo "VPC ID: ${{ steps.vpc.outputs.vpc_id }}"
          echo "Security Group ID: ${{ steps.vpc.outputs.sg_id }}"
          echo ""
          echo "These resources will trigger Cloud Custodian policies!"

  # ======================================================================
  # Job 3: Dry Run Policy (No Actions Executed)
  # ======================================================================
  dry-run-policy:
    name: Dry Run - ${{ inputs.policies_to_test }}
    runs-on: ubuntu-latest
    needs: validate-policy
    if: inputs.test_action == 'dry-run' || inputs.test_action == 'live-test'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials (Central Account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.CENTRAL_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Assume role in Member Account
        run: |
          echo "üîê Assuming OrganizationAccountAccessRole in member account..."
          
          CREDENTIALS=$(aws sts assume-role \
            --role-arn "arn:aws:iam::${{ env.MEMBER_ACCOUNT_ID }}:role/OrganizationAccountAccessRole" \
            --role-session-name "github-actions-dry-run" \
            --duration-seconds 3600 \
            --output json)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          
          # Verify we're in the member account
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "‚úÖ Assumed role in account: $ACCOUNT_ID"
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Cloud Custodian
        run: |
          pip install c7n c7n-org pyyaml boto3
          custodian version
      
      - name: Create filtered policy file
        if: inputs.policies_to_test != 'all'
        run: |
          echo "üìù Creating filtered policy file for: ${{ inputs.policies_to_test }}"
          
          python <<EOF
          import yaml
          
          with open('c7n/policies/aws-ec2-security.yml') as f:
              data = yaml.safe_load(f)
          
          # Filter for selected policy
          filtered_policies = [p for p in data['policies'] if p['name'] == '${{ inputs.policies_to_test }}']
          
          if not filtered_policies:
              print(f"Error: Policy '${{ inputs.policies_to_test }}' not found")
              exit(1)
          
          filtered_data = {'policies': filtered_policies}
          
          with open('filtered-policy.yml', 'w') as f:
              yaml.dump(filtered_data, f, default_flow_style=False)
          
          print(f"‚úÖ Filtered policy file created with {len(filtered_policies)} policy(ies)")
          EOF
      
      - name: Run policy in dry-run mode
        id: dryrun
        run: |
          echo "üß™ Running policy in dry-run mode (no actions executed)..."
          echo "Target Account: ${{ env.MEMBER_ACCOUNT_ID }}"
          
          if [ "${{ inputs.policies_to_test }}" == "all" ]; then
            POLICY_FILE="c7n/policies/aws-ec2-security.yml"
          else
            POLICY_FILE="filtered-policy.yml"
          fi
          
          OUTPUT_DIR="test-output/$(date +%Y%m%d-%H%M%S)"
          
          mkdir -p "$OUTPUT_DIR"
          
          # Run in dry-run mode
          custodian run \
            -s "$OUTPUT_DIR" \
            --region ${{ env.AWS_REGION }} \
            --dryrun \
            "$POLICY_FILE" 2>&1 | tee dryrun-output.log
          
          echo "‚úÖ Dry-run completed!"
      
      - name: Analyze dry-run results
        run: |
          echo "üìä Analyzing dry-run results..."
          
          OUTPUT_DIR="test-output"
          
          # Find the latest output directory
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          echo "Results directory: $LATEST_DIR"
          ls -la "$LATEST_DIR" || echo "No output directory found"
          
          # Check for resources.json in subdirectories
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              echo ""
              echo "Policy: $POLICY_NAME"
              
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "  Resources matched: $RESOURCE_COUNT"
                
                if [ "$RESOURCE_COUNT" -gt 0 ]; then
                  echo "  Sample resources:"
                  jq -r '.[] | .Name // .id // .Id // .InstanceId // .BucketName // "Unknown"' "$policy_dir/resources.json" | head -10
                fi
              else
                echo "  No resources.json found"
              fi
            fi
          done
      
      - name: Generate dry-run report
        run: |
          OUTPUT_DIR="test-output"
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          cat <<EOF > dryrun-report.md
          ## üß™ Policy Dry-Run Report
          
          **Policy:** \`${{ inputs.policies_to_test }}\`
          **Execution Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **AWS Region:** ${{ env.AWS_REGION }}
          **Target Account:** Member Account (${{ env.MEMBER_ACCOUNT_ID }})
          **Mode:** Dry-Run (No actions executed)
          
          ### Execution Summary
          
          EOF
          
          # Add resource counts per policy
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "- **$POLICY_NAME**: $RESOURCE_COUNT resources matched" >> dryrun-report.md
              fi
            fi
          done
          
          cat <<EOF >> dryrun-report.md
          
          ### Important Notes
          
          - ‚ö†Ô∏è This was a **DRY-RUN** - no actions were executed
          - Resources listed above would be affected in a live run
          - Review the matched resources before live execution
          
          ### Next Steps
          
          1. Review matched resources
          2. Adjust filters if needed
          3. Test with live-test action (caution!)
          4. Deploy to Lambda for scheduled execution
          
          EOF
          
          cat dryrun-report.md
      
      - name: Upload dry-run artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dryrun-results-${{ inputs.policies_to_test }}
          path: |
            test-output/
            dryrun-output.log
            dryrun-report.md
          retention-days: 30

  # ======================================================================
  # Job 4: Live Test (Execute Actions - USE WITH CAUTION!)
  # ======================================================================
  live-test-policy:
    name: Live Test - ${{ inputs.policies_to_test }}
    runs-on: ubuntu-latest
    needs: [validate-policy, dry-run-policy, create-test-ec2]
    if: inputs.test_action == 'live-test'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials (Central Account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.CENTRAL_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Assume role in Member Account
        run: |
          echo "üîê Assuming OrganizationAccountAccessRole in member account..."
          
          CREDENTIALS=$(aws sts assume-role \
            --role-arn "arn:aws:iam::${{ env.MEMBER_ACCOUNT_ID }}:role/OrganizationAccountAccessRole" \
            --role-session-name "github-actions-live-test" \
            --duration-seconds 3600 \
            --output json)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          
          # Verify we're in the member account
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "‚úÖ Assumed role in account: $ACCOUNT_ID"
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
      
      - name: Install Cloud Custodian
        run: |
          pip install c7n c7n-org pyyaml boto3
          custodian version
      
      - name: Warning banner
        run: |
          echo "::warning::‚ö†Ô∏è LIVE TEST MODE - Actions will be EXECUTED!"
          echo "::warning::This will make REAL changes to AWS resources in Member Account!"
          echo "::warning::Target Account: ${{ env.MEMBER_ACCOUNT_ID }}"
          sleep 5
      
      - name: Create filtered policy file
        if: inputs.policies_to_test != 'all'
        run: |
          echo "üìù Creating filtered policy file for: ${{ inputs.policies_to_test }}"
          
          python <<EOF
          import yaml
          
          with open('c7n/policies/aws-ec2-security.yml') as f:
              data = yaml.safe_load(f)
          
          # Filter for selected policy
          filtered_policies = [p for p in data['policies'] if p['name'] == '${{ inputs.policies_to_test }}']
          
          if not filtered_policies:
              print(f"Error: Policy '${{ inputs.policies_to_test }}' not found")
              exit(1)
          
          filtered_data = {'policies': filtered_policies}
          
          with open('filtered-policy.yml', 'w') as f:
              yaml.dump(filtered_data, f, default_flow_style=False)
          
          print(f"‚úÖ Filtered policy file created with {len(filtered_policies)} policy(ies)")
          EOF
      
      - name: Run policy in live mode
        id: live
        run: |
          echo "üö® Running policy in LIVE mode..."
          echo "Target Account: ${{ env.MEMBER_ACCOUNT_ID }}"
          
          if [ "${{ inputs.policies_to_test }}" == "all" ]; then
            POLICY_FILE="c7n/policies/aws-ec2-security.yml"
          else
            POLICY_FILE="filtered-policy.yml"
          fi
          
          OUTPUT_DIR="live-output/$(date +%Y%m%d-%H%M%S)"
          
          mkdir -p "$OUTPUT_DIR"
          
          # Run in live mode (actions will be executed!)
          custodian run \
            -s "$OUTPUT_DIR" \
            --region ${{ env.AWS_REGION }} \
            "$POLICY_FILE" 2>&1 | tee live-output.log
          
          echo "‚úÖ Live execution completed!"
      
      - name: Analyze live results
        run: |
          echo "üìä Analyzing live execution results..."
          
          OUTPUT_DIR="live-output"
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              echo ""
              echo "Policy: $POLICY_NAME"
              
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "  Resources processed: $RESOURCE_COUNT"
              fi
              
              if [ -f "$policy_dir/action.log" ]; then
                echo "  Action log:"
                cat "$policy_dir/action.log"
              fi
            fi
          done
      
      - name: Generate live test report
        run: |
          OUTPUT_DIR="live-output"
          LATEST_DIR=$(ls -td "$OUTPUT_DIR"/* | head -1)
          
          cat <<EOF > live-test-report.md
          ## üö® Live Policy Execution Report
          
          **Policy:** \`${{ inputs.policies_to_test }}\`
          **Execution Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **AWS Region:** ${{ env.AWS_REGION }}
          **Target Account:** Member Account (${{ env.MEMBER_ACCOUNT_ID }})
          **Mode:** LIVE (Actions EXECUTED)
          
          ### ‚ö†Ô∏è WARNING
          
          This was a **LIVE EXECUTION** - actions were performed on real AWS resources!
          
          ### Execution Summary
          
          EOF
          
          for policy_dir in "$LATEST_DIR"/*; do
            if [ -d "$policy_dir" ]; then
              POLICY_NAME=$(basename "$policy_dir")
              if [ -f "$policy_dir/resources.json" ]; then
                RESOURCE_COUNT=$(jq '. | length' "$policy_dir/resources.json")
                echo "- **$POLICY_NAME**: $RESOURCE_COUNT resources processed" >> live-test-report.md
              fi
            fi
          done
          
          cat <<EOF >> live-test-report.md
          
          ### Actions Taken
          
          Review the action logs and CloudWatch Logs for detailed information about actions performed.
          
          ### Next Steps
          
          1. Verify changes in AWS Console
          2. Check CloudWatch Logs for detailed execution
          3. Review any errors or warnings
          4. Adjust policy if needed
          5. Deploy to production Lambda
          
          EOF
          
          cat live-test-report.md
      
      - name: Upload live test artifacts
        uses: actions/upload-artifact@v4
        with:
          name: live-test-results-${{ inputs.policies_to_test }}
          path: |
            live-output/
            live-output.log
            live-test-report.md
          retention-days: 90

      - name: Send notification
        run: |
          echo "::notice::‚úÖ Live policy test completed for ${{ inputs.policies_to_test }}"
          echo "::notice::Review artifacts and CloudWatch Logs for details"

  # ======================================================================
  # Job 5: Test Lambda Integration
  # ======================================================================
  test-lambda-integration:
    name: Test Lambda Integration
    runs-on: ubuntu-latest
    needs: validate-policy
    if: inputs.test_action == 'live-test'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Option 1: OIDC (Recommended)
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Find Lambda function
        id: lambda
        run: |
          # Try to find Lambda function by name pattern
          FUNCTION_NAME=$(aws lambda list-functions \
            --query "Functions[?contains(FunctionName, 'custodian')].FunctionName | [0]" \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ -z "$FUNCTION_NAME" ] || [ "$FUNCTION_NAME" == "None" ]; then
            echo "::warning::No Cloud Custodian Lambda function found"
            echo "found=false" >> $GITHUB_OUTPUT
          else
            echo "found=true" >> $GITHUB_OUTPUT
            echo "function_name=$FUNCTION_NAME" >> $GITHUB_OUTPUT
            echo "‚úÖ Found Lambda function: $FUNCTION_NAME"
          fi
      
      - name: Test Lambda with policy
        if: steps.lambda.outputs.found == 'true'
        run: |
          echo "üß™ Testing Lambda function with policy..."
          
          PAYLOAD=$(cat <<EOF
          {
            "policy_source": "file",
            "policy_path": "/var/task/policies/${{ inputs.policy_file }}",
            "dryrun": true,
            "region": "${{ env.AWS_REGION }}"
          }
          EOF
          )
          
          aws lambda invoke \
            --function-name ${{ steps.lambda.outputs.function_name }} \
            --payload "$PAYLOAD" \
            --log-type Tail \
            --region ${{ env.AWS_REGION }} \
            lambda-response.json
          
          echo "Lambda response:"
          cat lambda-response.json | jq .
          
          echo "‚úÖ Lambda integration test completed!"
      
      - name: Check CloudWatch Logs
        if: steps.lambda.outputs.found == 'true'
        run: |
          echo "üìã Checking Lambda CloudWatch Logs..."
          
          LOG_GROUP="/aws/lambda/${{ steps.lambda.outputs.function_name }}"
          
          aws logs tail "$LOG_GROUP" \
            --since 5m \
            --format short \
            --region ${{ env.AWS_REGION }} || echo "No recent logs found"

  # ======================================================================
  # Job 6: Cleanup Test Resources
  # ======================================================================
  cleanup-test-resources:
    name: Cleanup Test Resources - ${{ inputs.policies_to_test }}
    runs-on: ubuntu-latest
    needs: [create-test-ec2, live-test-policy]
    if: always() && inputs.test_action == 'live-test'
    
    steps:
      - name: Configure AWS credentials (Central Account)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.CENTRAL_ACCOUNT_ID }}:role/GitHubActions-CloudCustodian-Role
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Assume role in Member Account
        run: |
          echo "üîê Assuming OrganizationAccountAccessRole in member account..."
          
          CREDENTIALS=$(aws sts assume-role \
            --role-arn "arn:aws:iam::${{ env.MEMBER_ACCOUNT_ID }}:role/OrganizationAccountAccessRole" \
            --role-session-name "github-actions-cleanup" \
            --duration-seconds 3600 \
            --output json)
          
          echo "AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')" >> $GITHUB_ENV
          echo "AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')" >> $GITHUB_ENV
          echo "AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')" >> $GITHUB_ENV
          
          # Verify we're in the member account
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          echo "‚úÖ Assumed role in account: $ACCOUNT_ID"
      
      - name: Cleanup AMI
        if: needs.create-test-ec2.outputs.ami_id != ''
        run: |
          echo "üßπ Cleaning up AMI..."
          
          AMI_ID="${{ needs.create-test-ec2.outputs.ami_id }}"
          
          if [ -n "$AMI_ID" ]; then
            # Deregister AMI
            aws ec2 deregister-image \
              --image-id $AMI_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to deregister AMI"
            
            echo "‚úÖ AMI deregistered"
          fi
      
      - name: Cleanup Snapshots
        if: needs.create-test-ec2.outputs.snapshot_id != ''
        run: |
          echo "üßπ Cleaning up snapshots..."
          
          SNAPSHOT_ID="${{ needs.create-test-ec2.outputs.snapshot_id }}"
          
          if [ -n "$SNAPSHOT_ID" ]; then
            # Delete snapshot
            aws ec2 delete-snapshot \
              --snapshot-id $SNAPSHOT_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to delete snapshot"
            
            echo "‚úÖ Snapshot deleted"
          fi
          
          # Cleanup any AMI-related snapshots
          AMI_ID="${{ needs.create-test-ec2.outputs.ami_id }}"
          if [ -n "$AMI_ID" ]; then
            echo "Checking for AMI snapshots..."
            SNAPSHOT_IDS=$(aws ec2 describe-snapshots \
              --owner-ids self \
              --filters "Name=description,Values=*$AMI_ID*" \
              --query 'Snapshots[].SnapshotId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for SNAP_ID in $SNAPSHOT_IDS; do
              echo "Deleting AMI snapshot: $SNAP_ID"
              aws ec2 delete-snapshot \
                --snapshot-id $SNAP_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete snapshot"
            done
          fi
      
      - name: Cleanup EC2 instance
        if: needs.create-test-ec2.outputs.instance_id != ''
        run: |
          echo "üßπ Cleaning up EC2 instance..."
          
          INSTANCE_ID="${{ needs.create-test-ec2.outputs.instance_id }}"
          
          if [ -n "$INSTANCE_ID" ]; then
            # Terminate instance
            aws ec2 terminate-instances \
              --instance-ids $INSTANCE_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to terminate instance"
            
            echo "‚è≥ Waiting for instance to terminate..."
            aws ec2 wait instance-terminated \
              --instance-ids $INSTANCE_ID \
              --region ${{ env.AWS_REGION }} || echo "Wait timeout"
            
            echo "‚úÖ Instance terminated"
          fi
      
      - name: Cleanup EBS volume
        if: needs.create-test-ec2.outputs.volume_id != ''
        run: |
          echo "üßπ Cleaning up EBS volume..."
          
          VOLUME_ID="${{ needs.create-test-ec2.outputs.volume_id }}"
          
          if [ -n "$VOLUME_ID" ]; then
            # Wait a bit for volume to detach
            sleep 10
            
            # Delete volume
            aws ec2 delete-volume \
              --volume-id $VOLUME_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to delete volume (may already be deleted)"
            
            echo "‚úÖ Volume deleted"
          fi
      
      - name: Cleanup VPC resources
        run: |
          echo "üßπ Cleaning up VPC and networking resources..."
          
          # Find test VPC
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=tag:Name,Values=custodian-test-vpc" \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region ${{ env.AWS_REGION }})
          
          if [ "$VPC_ID" != "None" ] && [ -n "$VPC_ID" ]; then
            echo "Found VPC: $VPC_ID"
            
            # Delete security groups (except default)
            SG_IDS=$(aws ec2 describe-security-groups \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'SecurityGroups[?GroupName!=`default`].GroupId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for SG_ID in $SG_IDS; do
              echo "Deleting security group: $SG_ID"
              aws ec2 delete-security-group \
                --group-id $SG_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete SG"
            done
            
            # Delete subnets
            SUBNET_IDS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[].SubnetId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for SUBNET_ID in $SUBNET_IDS; do
              echo "Deleting subnet: $SUBNET_ID"
              aws ec2 delete-subnet \
                --subnet-id $SUBNET_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete subnet"
            done
            
            # Detach and delete internet gateways
            IGW_IDS=$(aws ec2 describe-internet-gateways \
              --filters "Name=attachment.vpc-id,Values=$VPC_ID" \
              --query 'InternetGateways[].InternetGatewayId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for IGW_ID in $IGW_IDS; do
              echo "Detaching and deleting IGW: $IGW_ID"
              aws ec2 detach-internet-gateway \
                --internet-gateway-id $IGW_ID \
                --vpc-id $VPC_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to detach IGW"
              aws ec2 delete-internet-gateway \
                --internet-gateway-id $IGW_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete IGW"
            done
            
            # Delete route tables (except main)
            RT_IDS=$(aws ec2 describe-route-tables \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'RouteTables[?Associations[0].Main!=`true`].RouteTableId' \
              --output text \
              --region ${{ env.AWS_REGION }})
            
            for RT_ID in $RT_IDS; do
              echo "Deleting route table: $RT_ID"
              aws ec2 delete-route-table \
                --route-table-id $RT_ID \
                --region ${{ env.AWS_REGION }} || echo "Failed to delete route table"
            done
            
            # Finally delete VPC
            echo "Deleting VPC: $VPC_ID"
            aws ec2 delete-vpc \
              --vpc-id $VPC_ID \
              --region ${{ env.AWS_REGION }} || echo "Failed to delete VPC"
            
            echo "‚úÖ VPC cleanup completed"
          else
            echo "No test VPC found to clean up"
          fi
      
      - name: Cleanup summary
        run: |
          echo "‚úÖ Cleanup completed!"
          echo "All test resources have been removed."
